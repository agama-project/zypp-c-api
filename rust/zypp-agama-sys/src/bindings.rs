/* automatically generated by rust-bindgen 0.70.1 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProgressData {
    pub value: ::std::os::raw::c_longlong,
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ProgressData"][::std::mem::size_of::<ProgressData>() - 16usize];
    ["Alignment of ProgressData"][::std::mem::align_of::<ProgressData>() - 8usize];
    ["Offset of field: ProgressData::value"][::std::mem::offset_of!(ProgressData, value) - 0usize];
    ["Offset of field: ProgressData::name"][::std::mem::offset_of!(ProgressData, name) - 8usize];
};
pub type ZyppProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        zypp_data: ProgressData,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub const PROBLEM_RESPONSE_PROBLEM_RETRY: PROBLEM_RESPONSE = 0;
pub const PROBLEM_RESPONSE_PROBLEM_ABORT: PROBLEM_RESPONSE = 1;
pub const PROBLEM_RESPONSE_PROBLEM_IGNORE: PROBLEM_RESPONSE = 2;
pub type PROBLEM_RESPONSE = ::std::os::raw::c_uint;
pub type ZyppDownloadStartCallback = ::std::option::Option<
    unsafe extern "C" fn(
        url: *const ::std::os::raw::c_char,
        localfile: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
pub type ZyppDownloadProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        value: ::std::os::raw::c_int,
        url: *const ::std::os::raw::c_char,
        bps_avg: f64,
        bps_current: f64,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type ZyppDownloadProblemCallback = ::std::option::Option<
    unsafe extern "C" fn(
        url: *const ::std::os::raw::c_char,
        error: ::std::os::raw::c_int,
        description: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> PROBLEM_RESPONSE,
>;
pub type ZyppDownloadFinishCallback = ::std::option::Option<
    unsafe extern "C" fn(
        url: *const ::std::os::raw::c_char,
        error: ::std::os::raw::c_int,
        reason: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DownloadProgressCallbacks {
    pub start: ZyppDownloadStartCallback,
    pub start_data: *mut ::std::os::raw::c_void,
    pub progress: ZyppDownloadProgressCallback,
    pub progress_data: *mut ::std::os::raw::c_void,
    pub problem: ZyppDownloadProblemCallback,
    pub problem_data: *mut ::std::os::raw::c_void,
    pub finish: ZyppDownloadFinishCallback,
    pub finish_data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DownloadProgressCallbacks"]
        [::std::mem::size_of::<DownloadProgressCallbacks>() - 64usize];
    ["Alignment of DownloadProgressCallbacks"]
        [::std::mem::align_of::<DownloadProgressCallbacks>() - 8usize];
    ["Offset of field: DownloadProgressCallbacks::start"]
        [::std::mem::offset_of!(DownloadProgressCallbacks, start) - 0usize];
    ["Offset of field: DownloadProgressCallbacks::start_data"]
        [::std::mem::offset_of!(DownloadProgressCallbacks, start_data) - 8usize];
    ["Offset of field: DownloadProgressCallbacks::progress"]
        [::std::mem::offset_of!(DownloadProgressCallbacks, progress) - 16usize];
    ["Offset of field: DownloadProgressCallbacks::progress_data"]
        [::std::mem::offset_of!(DownloadProgressCallbacks, progress_data) - 24usize];
    ["Offset of field: DownloadProgressCallbacks::problem"]
        [::std::mem::offset_of!(DownloadProgressCallbacks, problem) - 32usize];
    ["Offset of field: DownloadProgressCallbacks::problem_data"]
        [::std::mem::offset_of!(DownloadProgressCallbacks, problem_data) - 40usize];
    ["Offset of field: DownloadProgressCallbacks::finish"]
        [::std::mem::offset_of!(DownloadProgressCallbacks, finish) - 48usize];
    ["Offset of field: DownloadProgressCallbacks::finish_data"]
        [::std::mem::offset_of!(DownloadProgressCallbacks, finish_data) - 56usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Repository {
    #[doc = "< owned"]
    pub url: *mut ::std::os::raw::c_char,
    #[doc = "< owned"]
    pub alias: *mut ::std::os::raw::c_char,
    #[doc = "< owned"]
    pub userName: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Repository"][::std::mem::size_of::<Repository>() - 24usize];
    ["Alignment of Repository"][::std::mem::align_of::<Repository>() - 8usize];
    ["Offset of field: Repository::url"][::std::mem::offset_of!(Repository, url) - 0usize];
    ["Offset of field: Repository::alias"][::std::mem::offset_of!(Repository, alias) - 8usize];
    ["Offset of field: Repository::userName"]
        [::std::mem::offset_of!(Repository, userName) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RepositoryList {
    pub size: ::std::os::raw::c_uint,
    #[doc = "< owned, *size* items"]
    pub repos: *mut Repository,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RepositoryList"][::std::mem::size_of::<RepositoryList>() - 16usize];
    ["Alignment of RepositoryList"][::std::mem::align_of::<RepositoryList>() - 8usize];
    ["Offset of field: RepositoryList::size"]
        [::std::mem::offset_of!(RepositoryList, size) - 0usize];
    ["Offset of field: RepositoryList::repos"]
        [::std::mem::offset_of!(RepositoryList, repos) - 8usize];
};
#[doc = " status struct to pass and obtain from calls that can fail.\n After usage free with \\ref free_status function.\n\n Most functions act as *constructors* for this, taking a pointer\n to it as an output parameter, disregarding the struct current contents\n and filling it in. Thus, if you reuse a `Status` without \\ref free_status\n in between, `error` will leak."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Status {
    pub state: Status_STATE,
    #[doc = "< owned"]
    pub error: *mut ::std::os::raw::c_char,
}
pub const Status_STATE_STATE_SUCCEED: Status_STATE = 0;
pub const Status_STATE_STATE_FAILED: Status_STATE = 1;
pub type Status_STATE = ::std::os::raw::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Status"][::std::mem::size_of::<Status>() - 16usize];
    ["Alignment of Status"][::std::mem::align_of::<Status>() - 8usize];
    ["Offset of field: Status::state"][::std::mem::offset_of!(Status, state) - 0usize];
    ["Offset of field: Status::error"][::std::mem::offset_of!(Status, error) - 8usize];
};
#[doc = " Progress reporting callback used by methods that takes longer.\n @param text  text for user describing what is happening now\n @param stage current stage number starting with 0\n @param total count of stages. It should not change during single call of method.\n @param user_data is never touched by method and is used only to pass local data for callback\n @todo Do we want to support response for callback that allows early exit of execution?"]
pub type ProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        text: *const ::std::os::raw::c_char,
        stage: ::std::os::raw::c_uint,
        total: ::std::os::raw::c_uint,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn set_zypp_progress_callback(
        progress: ZyppProgressCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
    pub fn free_status(s: *mut Status);
    #[doc = " Initialize Zypp target (where to install packages to)\n @param root\n @param[out] status\n @param progress\n @param user_data"]
    pub fn init_target(
        root: *const ::std::os::raw::c_char,
        status: *mut Status,
        progress: ProgressCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
    #[doc = " repository array in list.\n when no longer needed, use \\ref free_repository_list to release memory"]
    pub fn list_repositories() -> RepositoryList;
    pub fn free_repository_list(repo_list: *mut RepositoryList);
    #[doc = " Adds repository to repo manager\n @param alias have to be unique\n @param url can contain repo variables\n @param[out] status (will overwrite existing contents)\n @param callback pointer to function with callback or NULL\n @param user_data"]
    pub fn add_repository(
        alias: *const ::std::os::raw::c_char,
        url: *const ::std::os::raw::c_char,
        status: *mut Status,
        callback: ZyppProgressCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
    #[doc = " Removes repository from repo manager\n @param alias have to be unique\n @param[out] status (will overwrite existing contents)\n @param callback pointer to function with callback or NULL\n @param user_data"]
    pub fn remove_repository(
        alias: *const ::std::os::raw::c_char,
        status: *mut Status,
        callback: ZyppProgressCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
    #[doc = "\n @param alias alias of repository to refresh\n @param[out] status (will overwrite existing contents)\n @param callbacks pointer to struct with callbacks or NULL if no progress is needed"]
    pub fn refresh_repository(
        alias: *const ::std::os::raw::c_char,
        status: *mut Status,
        callbacks: *mut DownloadProgressCallbacks,
    );
    pub fn free_zypp();
}
